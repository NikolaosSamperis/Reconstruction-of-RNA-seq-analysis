---
title: "Reconstruction of Rna-seq bioinformatics analysis for *Adaptive laboratory evolution of native methanol assimilation in Saccharomyces cerevisiae*"
author: "Nikolaos Samperis, Madiha Khan, Yixin Huang" 
date: "2024-12-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
true=TRUE
false=FALSE
```

<br> <br> <br>

## Module 7BBG1002 group 1

### Connecting to CREATE HPC

```{bash eval=FALSE, include=TRUE}
# Log in to HPC.
ssh -i~/.ssh/"key name" k********@hpc.create.kcl.ac.uk
```

### Create directories to store raw data, outputs and reference genome.

```{bash eval=FALSE, include=TRUE}
cd /scratch_tmp/grp/msc_appbio
mkdir group1
cd group1
mkdir raw_reads
mkdir ref_gen
mkdir outputs
```

### Acquiring sequences from the sequence read archive (SRA) with SRA Toolkit.

To download the sequences from the SRA, the SRA Toolkit was used. *fasterq-dump* is part of the SRA package and it was used to fetch the SRA files and convert them to FASTQ. The --gzip function is not supported in *fasterq-dump* and thus, we run it after downloading and converting had finished. --split-files was used to split the forward from the reverse reads as our data were paired-end.

```{bash eval=FALSE, include=TRUE}
# Go to the right directory.
cd /scratch_tmp/grp/msc_appbio/group1/raw_reads

# Searching for available modules corresponding to SRA Tools
module spider SRA Tools

# Loading module
module load sra-tools/3.0.3-gcc-13.2.0

fasterq-dump --split-files SRR11318268, SRR11318269, SRR11318270, SRR11318271 -O .

# After downloading and converting the SRA files to FASTQ, compress all the files in the directory.
gzip *
```

The results from downloading with --split-files gives 2 files per SRA, as mentioned before, one forward and one reverse. The suffix of the split files in the raw_reads/ directory is one with \_1.fastq.gz and another with \_2.fastq.gz.

### FastQC

Creating conda environment to install and activate packages. Best practice for reproducibility and dependency management in computational workflows, especially if you work locally or the HPC does not provide a specific tool.

```{bash eval=FALSE, include=TRUE}
# Searching for conda in the HPC
module spider conda

# Loading conda
module load anaconda3/2021.05-gcc-13.2.0

# Creating conda environment 
create conda -â€”name myenv

# Activating conda environment
conda activate myenv

# Installing FastQC and MultiQC from Bioconda repository
conda install -c bioconda fastqc multiqc samtools

# Deactivating conda environment
conda deactivate
```

In the end, we did not use our conda environment to run FastQC and MultiQC as these modules are already installed in the HPC. We made a SBATCH script to perform FastQC and MultiQC to our raw fastq.gz files.

```{bash eval=FALSE, include=TRUE}
# Create and edit the script with nano.
nano fastqc.sh

#!/bin/bash

echo "start of pipeline"

module load fastqc
module load py-multiqc

# Specify input and output directories.
baseDirectory="/scratch_tmp/grp/msc_appbio/group1/raw_reads"
resultsDirectory="/scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output"

# Create results directory  if it does not exist. 
mkdir -p "$resultsDirectory"

# Run FastQC on all .fastq.gz files in baseDirectory
fastqc -o "$resultsDirectory" -t 4 "$baseDirectory"/*.fastq.gz 

echo "end of fastqc pipeline" 

echo "start of multiqc"

multiqc "$resultsDirectory"

echo "end of multiqc"

# Run the script interactively in the msc_appbio partition.
srun msc_appbio --pty /bin/bash
sbatch fastqc.sh
squeue -u k24090847

# Or run the script as a sbatch job. Select partition and specify cpu number if you do not want the default resources. 
sbatch -p msc_appbio --cpus-per-task = 12 fastqc.sh

# Check the status of your sbatch job.
squeue -u "knumber"

# Choose the rightdirectory to view the output files.
cd /scratch_tmp/grp/msc_appbio/group1/outputs

# List contents of the outputs directory.
ls

```

Move processed FASTQ files to local desktop from HPC using your local terminal.

```{bash eval=FALSE, include=TRUE}
# Open a terminal window and log into the remote server using sftp.
sftp -i~/.ssh/"key name" k********@hpc.create.kcl.ac.uk


# Change to the local directory where files will be downloaded
lcd /Users/User/Desktop


get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318268_1_fastqc.html 
get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318268_2_fastqc.html 

get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318269_1_fastqc.html 
get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318269_2_fastqc.html 

get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318270_1_fastqc.html  
get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318270_2_fastqc.html

get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318271_1_fastqc.html
get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/SRR11318271_2_fastqc.html

get /scratch_tmp/grp/msc_appbio/group1/outputs/fastqc_output/multiqc_report.html
```

### Alignment with STAR

Download the reference genome to the HPC with NCBI Datasets Command Line (CLI) tools. We require the FNA and GTF files.

```{bash eval=FALSE, include=TRUE}
# Select the correct directory.
cd /scratch_tmp/grp/msc_appbio/group1/ref_gen/

# Create a conda environment 
conda create -n ncbi_datasets

#Activate environment
conda activate ncbi_datasets

#Install ncbi-datasets-cli in the environment
conda install -c conda-forge ncbi-datasets-cli

# Download reference genome and specify the GTF (annotation file) and genome(FNA) file types.
datasets download genome accession GCF_000146045.2 --include genome,gtf

```

Index reference genome using STAR RNA-seq aligner

```{bash eval=FALSE, include=TRUE}
nano star_indexing.sh

#!/bin/bash
module load star/2.7.10b-gcc-13.2.0

# Ensure line 131 is run on a single line for alignment to work
STAR --runThreadN 16  --runMode genomeGenerate --genomeDir /scratch_tmp/grp/msc_appbio/group1/ref_gen --genomeFastaFiles/scratch_tmp/grp/msc_appbio/group1/ref_gen/GCF_000146045.2_R64_genomic.fna --sjdbGTFfile /scratch_tmp/grp/msc_appbio/group1/ref_gen/genomic.gtf 

```

Script of STAR alignment for paired-end RNA reads

```{bash eval=FALSE, include=TRUE}
#!/bin/bash

echo "start of pipeline"
module load star/2.7.10b-gcc-13.2.0

# Specify path to raw data
baseDir="/scratch_tmp/grp/msc_appbio/group1"

# Define path to STAR indexed reference genome
ref_genome_index="${baseDir}/ref_gen/starindex"

rawDataDir="${baseDir}/raw_reads/"
outputDataDir="${baseDir}/outputs/star_outs/"

# Create output directory if it doesn't exist
mkdir -p "$outputDataDir"

samples=$(ls "$rawDataDir"/*_1.fastq.gz | sed 's/_1.fastq.gz//' | xargs -n 1 basename)

# Loop where samples are aligned using STAR and the genome index, saving the outputs as sorted BAM file.
for sample in $samples; do #iterates through each item in the samples variable
        echo "Processing sample: $sample" #prints a message indicating which sample is being processed

STAR --runThreadN 6 --genomeDir "$ref_genome_index" --readFilesCommand zcat --readFilesIn "$rawDataDir${sample}_1.fastq.gz" "$rawDataDir${sample}_2.fastq.gz" --outFileNamePrefix "$outputDataDir${sample}_" --outSAMtype BAM SortedByCoordinate
#ensure line 160 is run on a single line for alignment to work

done
echo "STAR alignment complete!"
```

Use *SAMtools* to inspect first 10 lines of BAM file from STAR alignment

```{bash eval=FALSE, include=TRUE}
cd /scratch_tmp/grp/msc_appbio/group1/outputs
conda activate myenv
samtools view SRR11318268_Aligned.sortedByCoord.out.bam | head -n 10  
```

### Quantification of aligned reads using *featureCounts*

```{bash eval=FALSE, include=TRUE}
#!/bin/bash

# Load Modules
module load subread
module load py-multiqc
echo "modules loaded successfully."

# Define variables and paths
baseDir="/scratch_tmp/grp/msc_appbio/group1"
inputDir="${baseDir}/outputs/star_outs"
gtf_file="${baseDir}/ref_gen/raw_refgen/GCF_000146045.2"
output_Dir="${baseDir}/outputs/readCounts"
feature_type="db_xref"

# Create output directory if it doesn't exist
mkdir -p "$output_Dir"

# Run featureCounts tool

featureCounts -p -a ${gtf_file}/*.gtf -g $feature_type -o ${output_Dir}/readCounts2.txt ${inputDir}/*.out.bam

# Check if featureCounts ran successfully
if [[ $? -eq 0 ]]; then
  echo "featureCounts completed successfully. Results are in $output_Dir"
else
  echo "Error: featureCounts failed. Check your input files and parameters."
exit 1
fi

# Run multiQC
multiqc "$output_Dir"

# Check if MultiQC ran successfully
if [[ $? -eq 0 ]]; then
    echo "multiqc completed successfully"
else
    echo "Error: multiqc failed"
exit 1
fi
```

Transfer *featureCounts* output file out of HPC onto local desktop using *sftp*.

```{bash eval=FALSE, include=TRUE}
# Open a terminal window and log into the remote server using sftp.
sftp -i~/.ssh/"key name" k********@hpc.create.kcl.ac.uk


# Change to your local directory where files will be downloaded
lcd /Users/User/group_project7BBG1002

#Use get to retrieve the readCounts2.txt and readCounts2.txt.summary files

get /scratch_tmp/grp/msc_appbio/group1/outputs/readCounts/readCounts2.txt 
get /scratch_tmp/grp/msc_appbio/group1/outputs/readCounts/readCounts2.txt.summary 
```

### Moving to Rstudio

We will process, visualise and produce plots from our readCounts2.txt file using R version 4.4.1.

### Installing Packages

Installing the packages BiocManager, dplyr, gplots, ggplot2 and ggrepel.

```{r eval=FALSE, include=TRUE}
install.packages(c('BiocManager', 'dplyr', 'gplots', 'ggplot2', 'ggrepel', 'kableExtra'))
```

Installing the below packages with BiocManager.

```{r eval=FALSE, include=FALSE}
BiocManager::install(c('limma', 'DESeq2', 'AnnotationDbi', 'ReportingTools', 'GO.db', 'GOstats', 'pathview', 'gage', 'gageData', 'Select', 'ComplexHeatmap', 'EnhancedVolcano', 'clusterProfiler', 'org.Sc.sgd.db', 'circlize'))
```

### Import Read Counts File

Loading libraries. Importing dataset under "countData" variable.

```{r, message=FALSE, warning=FALSE}
# Loading libraries.

# Enhance and style tables generated with knitr::kable.
library(kableExtra)

# For differential gene expression analysis of RNA-seq data. 
library(DESeq2) 

# A package for data manipulation and transformation. 
library(dplyr) 

library(ggrepel) # For labeling purposes

# A popular package for data visualization in R.
library(ggplot2) 

# Provides various plotting functions, with a focus on heatmaps and other complex visualizations.
library(gplots) 

 # Specifically designed for creating complex heatmaps with rich annotations.
library(ComplexHeatmap)

# Provides a collection of color palettes that are suitable for various types of data visualizations.
library(RColorBrewer) 

# Used for circular visualizations, especially for displaying relationships between variables in a circular layout
library(circlize) 

# Provides methods for performing Gene Ontology (GO) statistical tests and enrichment analysis.
library(GOstats) 

# A database package providing GO (Gene Ontology) annotations.
library(GO.db) 

# Used for statistical analysis and visualization of functional profiles (e.g., GO, KEGG) of genes, proteins, or metabolites.
library(clusterProfiler) 

# A framework for storing, querying, and retrieving annotation data, such as gene symbols, IDs, and GO terms.
library(AnnotationDbi) 

# An organism-specific annotation database, in this case, for *Saccharomyces cerevisiae* (yeast).
library(org.Sc.sgd.db) 

# Versions of the packages used.

package.version('kableExtra')
package.version('DESeq2')
package.version('dplyr')
package.version('ggrepel')
package.version('ggplot2')
package.version('gplots')
package.version('ComplexHeatmap')
package.version('RColorBrewer')
package.version('circlize')
package.version('GOstats')
package.version('GO.db')
package.version('clusterProfiler')
package.version('AnnotationDbi')
package.version('org.Sc.sgd.db')

# Load our readCounts2.txt file and store it to countData parameter. Skip first row as it is metadata that we do not require.
countData = read.table('readCounts2.txt', sep = '\t', header=FALSE, skip = 1) 

# Convert to dataframe.
countData = as.data.frame(countData)

# Set column names to the values of the 1st row.
colnames(countData) = countData[1, ] 

# Remove 1st row.
countData = countData[-1, ]

# Rename our sample IDs to ReEC_2, ReEC_1, Control_2, Control_1 respectively.
colnames(countData)[colnames(countData) == "/scratch_tmp/grp/msc_appbio/group1/outputs/star_outs/SRR11318268_Aligned.sortedByCoord.out.bam"] = "ReEC_2"
colnames(countData)[colnames(countData) == "/scratch_tmp/grp/msc_appbio/group1/outputs/star_outs/SRR11318269_Aligned.sortedByCoord.out.bam"] = "ReEC_1"
colnames(countData)[colnames(countData) == "/scratch_tmp/grp/msc_appbio/group1/outputs/star_outs/SRR11318270_Aligned.sortedByCoord.out.bam"] = "Control_2"
colnames(countData)[colnames(countData) == "/scratch_tmp/grp/msc_appbio/group1/outputs/star_outs/SRR11318271_Aligned.sortedByCoord.out.bam"] = "Control_1"

# Make column Geneid our row IDs.
rownames(countData) = countData$Geneid

#Remove GenBank: from our row IDs
rownames(countData) = gsub("GenBank:", "", rownames(countData)) 

#Remove the .number from our row IDs
rownames(countData) = gsub("\\..*", "", rownames(countData)) 

# Remove columns 1 to 6.
countData = countData[,-c(1:6)]

countData[] = lapply(countData, as.numeric)

# Print head of countData. 
head(countData)

# Load Paper_Results.csv for comparison later.
Paper_results = read.csv("./Paper_results.csv", sep = ';', stringsAsFactors = FALSE)

# Convert specific columns to numeric and replace decimal point separator from ',' to '.'
Paper_results$Differential.Expression.Adjusted.p.value = as.numeric(gsub(",", ".",Paper_results$Differential.Expression.Adjusted.p.value))

Paper_results$Differential.Expression.Log2.Ratio = as.numeric(gsub(",", ".",Paper_results$Differential.Expression.Log2.Ratio))

Paper_results$Differential.Expression.p.value = as.numeric(gsub(",", ".",Paper_results$Differential.Expression.p.value))

# Display structure of the dataframe to verify format.
str(Paper_results)

# Make column locus_tag as rownames and delete redundant locus_tag column afterwards.
rownames(Paper_results) = Paper_results$locus_tag
Paper_results$locus_tag = NULL
```

### Quick Data Exploration

Summary of our dataset.

```{r}
summary(countData)
```

Read sums of read counts per sample.

```{r}
colSums(countData)
```

Barplot of our data (million counts per sample).

```{r}
# Fix margins of our output.
par(mar=c(8,5,4,2)+0.1) 

# Create barplot.
barplot(colSums(countData)/1e6, main = "Total Read Counts", xlab = "Samples", ylab = "Counts per Million")
```

Histogram of the first column of our dataset showing that the data are highly skewed to the right.

```{r}
# Fix margins of our output.
par(mar=c(7,5,4,4)+0.2) 

# Create histogram.
hist(countData$ReEC_2, xlim = c(0,120000), main = "Histogram of read counts for ReEC_2", xlab = "Number of read counts", br=1000)
```

Log Transformation. Taking the log2 for our sample read counts for better visualization.

```{r}
logCountData = log2(1 + countData)
```

Repeating our previous histogram of the first column of our dataset, but now with the log transformed data.

```{r}
# Fix margins of our output.
par(mar=c(7,5,4,4)+0.2)

# Create histogram with the log2 read counts
hist(logCountData$ReEC_2, xlim = c(0,20), main = "Histogram of read counts for ReEC_2", xlab = "Number of read counts", br=100)
```

Plotting Scatter Plot to observe the correlation between ReEC_2 and ReEC_1.

```{r}
# Fix margins of our output.
par(mar=c(7,5,4,2)+0.1)

# Create scatter plot.
plot(logCountData[,1], logCountData[,2], xlab = "ReEC_2", ylab = "ReEC_1")
```

Plotting Scatter Plot to observe the correlation between Control_2 and Control_1.

```{r}
# Fix margins of our output.
par(mar=c(7,5,4,2)+0.1)

# Create scatter plot.
plot(logCountData[,3], logCountData[,4], xlab = "Control_2", ylab = "Control_1")
```

Plotting Scatter Plot to observe the correlation between ReEC_2 and Control_2.

```{r}
# Fix margins of our output.
par(mar=c(7,5,4,2)+0.1)

# Create scatter plot.
plot(logCountData[,1], logCountData[,3], xlab = "ReEC_2", ylab = "Control_2")
```

### Normalization, and Trasformation using *DESeq2*

We have to make the experiment design into a small dataframe to associate each column (sample) in the countData object with a specific condition (mutated or control). Here we make a small table that has the sample/column names from our main dataset (countData) as row; and then a column for which columns of our main dataset are "treatment" or "control" respectively. This step is mandatory for DESeq2 package to properly analyse our data.

```{r}
# Define our groups and indicate that object "group" is a factor.
groups = factor(c("mutated", "mutated", "control", "control")) 

# Create dataframe
sample_info = data.frame(row.names = colnames(countData), condition = groups)
sample_info
```

Create a DESeqDataSet object (dds) using the DESeqDataSetFromMatrix function from the DESeq2 package. This dataset is then ready for downstream differential expression analysis.

```{r, message=FALSE}
# Create DESeq2 dataset
dds = DESeqDataSetFromMatrix(countData = countData, colData = sample_info, design = ~ condition)
```

Run the DESeq2 pipeline for differential expression analysis. Calculate significantly expressed genes using adjusted p-value cutoff of 0.01.

```{r message=FALSE}
# Main function
dds = DESeq(dds)

# Confirm the number of rows is the equal with our countData dataset. 
nrow(dds) 

# Results. The contrast argument specifies which groups to compare (in this case, mutated vs control). Default adjusted p-value is 0.1 but we set it to 0.01 based on the study we are trying to reproduce.
res = results(dds, contrast = c("condition", "mutated", "control"), alpha = 0.01) 

# Sorting the res table by the adjusted p-values (padj) in ascending order.
res = res[order(res$padj),] 

# Make a dataframe of res, so we can use it later to make a volcano plot.
res.df = as.data.frame(res)

# Remove N/A values.
res.df = na.omit(res.df) 

# Print head of res. 
head(res)

# Print summary of res.
summary(res)
```

We will now compare our results res.df to the study we are trying to reproduce. We will first create a subset of res.df with all the genes that present adjusted p-values(padj) \< 0.01 and store it to sigGenes object. This subset will contain all the significant differentially expressed genes based on padj threshold of 0.01.

```{r}
# Create subset of res.df.  
sigGenes = res.df[res.df$padj < 0.01,]

# Remove NA values. 
sigGenes = na.omit(sigGenes)

# Print dimentions of SigsPaper
dim(sigGenes)
```

Filtering Paper_results for significant differentially expressed genes based on a adjusted p-value cutoff of 0.01, and storing it to SigsPaper object.

```{r}
# Extract subset of significant differentially expressed genes from Paper_results.
SigsPaper = Paper_results[Paper_results$Differential.Expression.Adjusted.p.value < 0.01,]

SigsPaper = na.omit(SigsPaper)

# Print dimentions of SigsPaper
dim(SigsPaper)
```

Now we will try to map our results IDs of differentially expressed genes (sigGenes) with paper's ones (SigsPaper). To achieve this we will use org.Sc.sgd.db as a database to retrieve common IDs in both papers for comparison, since our dataset's IDs differ from the paper's ones. Therefore, we will make an extra column in sigGenes of COMMON IDs. We retrieve these IDs from org.Sc.sgd.db based on mapping to our row names (RefSeq ID type).

```{r}
# Make COMMON column and map RefSeq IDs to ENTREZ from org.Sc.sgd.db 
sigGenes$COMMON = mapIds(org.Sc.sgd.db, keys = rownames(sigGenes), column = "COMMON", keytype = "REFSEQ", multiVals = "first")

# Remove NA values from sigGenes.
sigGenes = na.omit(sigGenes)

# Search for presence of common IDs in the "COMMON" column of sigGenes to the "gene" column of SigsPaper.
CommonIDs = intersect(sigGenes$COMMON, SigsPaper$gene)

# Make CommonIDs a dataframe.
CommonIDs = data.frame(CommonIDs)

# Remove NA values from CommonIDs.
CommonIDs = na.omit(CommonIDs)

# Print CommonIDs dimensions.
dim(CommonIDs)
```

```{r}
# Print CommonIDs as a scroll table.
kable(CommonIDs) %>% 
  kable_styling() %>%
  scroll_box(width = "500px", height = "500px")
```

<br> By default, lfcThreshold is set to 0. The paper doesn't specify a log fold change (LFC) cutoff and we assume that DESeq2 default values were used. However, typical cutoffs of 1.3 to 4 fold change (FC) are applied along with the FDR threshold in most studies for a more accurate prediction of the differentially expressed genes. If we apply a log2 fold change threshold of 0.379 (\~1.3 FC) we can see that we get even less differentially expressed genes (significant) than the numbers mentioned in the paper.

```{r}
# Results. The contrast argument specifies which groups to compare (in this case, mutated vs control). Default adjusted p-value is 0.1 but we set it to 0.01 based on the study we are trying to reproduce. Log2 fold change threshold (lfcThreshold) is set to 0.379.
res.strict = results(dds, contrast = c("condition", "mutated", "control"), lfcThreshold = 0.379, alpha = 0.01)

# Sorting the res table by the adjusted p-values (padj) in ascending order.
res.strict = res.strict[order(res.strict$padj),] 

# Make a dataframe of res.strict, so we can use it later to make a volcano plot.
res.strict.df = as.data.frame(res.strict)

# Remove N/A values
res.strict.df = na.omit(res.strict.df)

# Print a summary of res.strict
summary(res.strict)
```

Filtering our differentially expressed genes based on log2FoldChange cutoff of \> 1.6 and adjusted p-value of \< 0.01 to reduce the number of genes and extract the top differentially expressed genes for better visualization in a heatmap.

```{r}
# Select genes from res.df with absolut log2FoldChange values > 1.6 and adjusted p-values < 0.01.
df.top = res.df[(abs(res.df$log2FoldChange) > 1.6) & (res.df$padj < 0.01),]

# Print df.top as dataframe with scroll bars.
kable(df.top) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

<br> Order df.top by the log2foldchange (Higher to lower values) for better visualization in the heatmap.

```{r}
# Reorder the rows of df.top based on the log2FoldChange column in descending order.
df.top = df.top[order(df.top$log2FoldChange, decreasing = TRUE),]
```

### Exploratory Data Analysis

Heatmap with *ComplexHeatmap*, *RColorBrewer* and *circlize* libraries

```{r}
# Apply a regularized log transformation (rlog) to the count data in the dds object.The blind = FALSE argument indicates that the transformation will not ignore the experimental design.
rld = rlog(dds, blind=FALSE) 

# Making a matrix of the log-transformed expression values for the top differentially expressed genes across all samples.
mat = assay(rld)[rownames(df.top), rownames(sample_info)]

# Ensure the column names of mat correspond to the sample names from the sample_info dataframe.
colnames(mat) = rownames(sample_info)

# Calculate the mean expression for each gene (across all samples). This give us an idea of the overall expression level of each gene across the samples in the heatmap.
base_mean = rowMeans(mat)

# Center and scale each column (Z-score), then transpose.
mat.scaled = t(apply(mat, 1, scale)) 
colnames(mat.scaled) = colnames(mat)
head(mat.scaled)
```

Making a matrix of the Log2FoldChange values of the filtered genes in df.top, to use it as an extra column in our heatmap.

```{r}
# Get log2FoldChange value for each gene in df.top.
l2_val = as.matrix(df.top$log2FoldChange) 

# Assign column name to the matrix.
colnames(l2_val) = "log2FC"

l2_val
```

Making a matrix of the baseMean values (Average gene expression across all samples) of the filtered genes in df.top to include as an extra column in our heatmap.

```{r}
# Make matrix of the mean values for each gene in df.top.
mean = as.matrix(df.top$baseMean) 

# Assign column name to the matrix.
colnames(mean) = "AvrgExpr"

mean
```

Creating a color map for our Log2FoldChange and Average gene expression values.

```{r}
# Define color scale for Z-scores, mapping low values to blue, zero to white, and high values to red.
col_z = colorRamp2(c(min(mat.scaled), 0, max(mat.scaled)), c("blue", "white", "red"))

# Maps values between b/w/r for min and max log2FoldChange values.
col_log2FC = colorRamp2(c(min(l2_val),0, max(l2_val)), c("blue", "white", "red"))

# Maps between 0% quantile, and 75% quantile of mean values --- 0, 25, 50, 75, 100.
col_AvrgExpr = colorRamp2(c(quantile(mean)[1], quantile(mean)[4]), c("white", "red"))
```

Creating a heatmap for the top 31 genes, consisting of 3 smaller heatmaps/columns that present the Z-score expression, the log2FoldChange in descending order, and the baseMean (Average gene expression) matrices respectively.

```{r fig.width=8, fig.height=12, message=FALSE, warning=FALSE}
# Create an annotation that will be used later to summarise the l2FC column of the heatmap. ha goes as input to h2 (heatmap 2). 
ha = HeatmapAnnotation(summary = anno_summary(gp = gpar(fill = 2), 
                                               height = unit(2, "cm")))
# Create heatmap 1 (Z-scores).
h1 = Heatmap(mat.scaled, cluster_rows = F, 
            column_labels = colnames(mat.scaled), column_names_gp = gpar(fontsize = 9), name="Z-score",
            cluster_columns = T, col = col_z, 
             show_heatmap_legend = FALSE)

# Create heatmap 2 (log2 Fold Change).
h2 = Heatmap(l2_val, row_labels = rownames(df.top), 
            cluster_rows = F, name="log2FC", top_annotation = ha, col = col_log2FC, show_heatmap_legend = FALSE, # Define color scheme for log2FC
            row_names_gp = gpar(fontsize = 8), column_names_gp = gpar(fontsize = 9), cell_fun = function(j, i, x, y, w, h, col) { # Add text to each grid.
              grid.text(round(l2_val[i, j],2), x, y, gp = gpar(fontsize = 7))
            }) # Round text to 2 decimals.

# Create heatmap 3 (Average Expression).
h3 = Heatmap(mean, row_labels = rownames(df.top), 
            cluster_rows = F, name = "AvrgExpr", col = col_AvrgExpr, show_heatmap_legend = FALSE,
            row_names_gp = gpar(fontsize = 7), column_names_gp = gpar(fontsize = 9), cell_fun = function(j, i, x, y, w, h, col) { # Add text to each grid.
              grid.text(round(mean[i, j],2), x, y, gp = gpar(fontsize = 7))
            }) # Round text to 2 decimals.

# Combine the heatmaps into one (h).
h = h1+h2+h3

# Extracting heatmap (h) into a PNG file. "png()" initializes the graphics device for saving the plot as a PNG file.
# png("./heatmap.png", res = 300, width = 2700, height = 5000)


# Create legends with spacing between title and color bar
lgd_list = list(
  Legend(title = "Z-score", col_fun = col_z, title_gap = unit(4, "mm")),
  Legend(title = "log2FC", col_fun = col_log2FC, title_gap = unit(4, "mm")),
  Legend(title = "AvrgExpr", col_fun = col_AvrgExpr, title_gap = unit(4, "mm"))
)

# Pack legends vertically with spacing between them
combined_legend = packLegend(
  lgd_list[[1]],
  lgd_list[[2]],
  lgd_list[[3]],
  direction = "vertical",
  gap = unit(10, "mm") # Increase gap between the legends
)

# Draw heatmap with packed legends on the right and apply padding
draw(h, 
     heatmap_legend_list = combined_legend, 
     heatmap_legend_side = "right", 
     padding = unit(c(10, 10, 10, 10), "mm"))

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()  
```

### Volcano Plot with *ggplot2* and *ggrepel*

We will initially create a basic volcano plot step by step from res.df that takes the default lfcThreshold (0) and only defines the significant differentially expressed genes based on the adjusted p-value (padj \< 0.01).

```{r}
# Set our x-axis and y-axis values to log2FoldChage and -log10(padj) respectively. We convert padj values to the scale of -log10 for better visualisation. "geom_point()" adds scatter plot points to the plot.
vol_plot = res.df %>%
  ggplot(aes(x = log2FoldChange, y = -log10(padj))) + geom_point()

# Visualise ggplot output
vol_plot 
```

### Adding horizontal and vertical lines based on our padj and log2FoldChange cutoff values.

We have set padj cutoff at 0.01 and since our y-axis is in -log10 scale we also need to convert our threshold to -log10. Our log2FoldChange (L2FC) cutoff is set at 0. This defines which genes are upregulated (L2FC \> 0) and which are downregulated (L2FC \< 0). A L2FC of 0 equals to fold change of 1. We will addWe have also set our x-axis range from -6 to 6.

```{r, message=FALSE}
# Add threshold lines for both statistical significance (y-axis) and fold change (x-axis), and adjust the x-axis scale.
vol_plot + geom_hline(yintercept = -log10(0.01), linetype = "dashed") +
  geom_vline(xintercept = log2(1), linetype = "dashed") + scale_x_continuous(breaks = c(seq(-6, 6, 1)), # Modify x-axis tick intervals.
                                                                                            limits = c(-6, 6)) + # Modify x-axis range from -6 to 6.
  ggtitle("ReEC(mutated) vs Control") + # Add title.
  theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5)) + # Format title.
  labs(subtitle = "(fold change = 0, adjusted p-value = 0.01)") + # Add subtitle.
  theme(plot.subtitle = element_text(size = 8, face = "italic", hjust = 0.5)) # Format subtitle.
```

### Add point colour, size and transparency

To visualise different groups of genes using different colours, point sizes, shapes or transparencies, we need to categorise genes into different groups and store these categories as a new parameter i.e. new column of data.

Genes with log2FoldChage \> 0 & adj_p_val \<= 0.01 as Upregulated.

Genes with log2FoldChage \< 0 & adj_p_val \<= 0.01 as Downregulated.

All other genes are labelled as Non-Significant.

```{r}
# Create a new dataframe(res.df2) based on the original res.df and add a new column(gene_type). The new gene_type column categorizes each row (gene) into one of these three groups: Upregulated, Downregulated, Non-Significant; based on the log2FoldChange(0) and the padj(0.01) cutoffs. 
res.df2 = res.df %>%
  mutate(
    gene_type = case_when(
      log2FoldChange > 0 & padj <= 0.01 ~ "Upregulated",
      log2FoldChange < 0 & padj <= 0.01 ~ "Downregulated",
      TRUE ~ "Non-Significant")) 

# Extract the gene_type column from the new dataframe(res.df2) and store it in a variable.
gene_type.object = res.df2$gene_type  

# Summarize the counts of each category in the gene_type column.
res.df2 %>%
  count(gene_type) 
```

```{r}
# Check gene_type category names.
res.df2 %>%
  distinct(gene_type) %>%
  pull()
```

In ggplot2, you also have the option to visualize different groups by point color, size, shape and transparency by modifying parameters via scale_color_manual() etc. A tidy way of doing this is to store each visual specifications in a separate vector.

```{r fig.width=10, fig.height=5, dpi=300, message=FALSE, warning=FALSE}
# Create vectors of custom colors and alphas (transparency) to volcano plot.
cols = c("Upregulated" = "#ffad73", "Downregulated" = "#26b3ff", "Non-Significant" = "grey") 
alphas = c("Upregulated" = 1, "Downregulated" = 1, "Non-Significant" = 0.5)

# Create a column in res.df2 that takes the rownames of our 20 most significant differentially expressed genes that will be used later for labeling purposes. This is possible as res.df2 is sorted in ascending order of the padj values.
res.df2 = res.df2 %>% mutate(top_20_genes = ifelse(row_number() <= 20, rownames(res.df2), NA))

# Create Volcano plot in the same way we did in the previous steps.
VolcanoPlot = ggplot( res.df2, aes(x = log2FoldChange,
             y = -log10(padj),
             fill = gene_type,
             size = gene_type,
             alpha = gene_type)) + 
  geom_point(shape = 21,     
             colour = "black", size = 2) + # Plot the points and modify color and size.
  geom_hline(yintercept = -log10(0.01),
             linetype = "dashed") + # Add dashed line in the y-axis at -log(0.01).
  geom_vline(xintercept = log2(1), 
             linetype = "dashed") + # Add dashed line in the x-axis at log2(1) fold change.
  scale_fill_manual(values = cols) + # Modify point color
  scale_alpha_manual(values = alphas) + # Modify point transparency
  scale_x_continuous(breaks = c(seq(-6, 6, 1)), # Modify x-axis tick intervals.
                     limits = c(-6, 6)) + # Modify x-axis range from -6 to 6.
  ggtitle("ReEC(mutated) vs Control") + # Add title.
  theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5)) + # Format title.
  labs(subtitle = "(fold change = 0, adjusted p-value = 0.01)") + # Add subtitle.
  theme(plot.subtitle = element_text(size = 8, face = "italic", hjust = 0.5)) + # Formt subtitle.
  geom_text_repel(aes(label = top_20_genes), # Add labels to the top 20 most significant differentially expressed genes.
                  size = 2, 
                  max.overlaps = Inf)

# Extracting Vol_plot2 into a PNG file and saving it to our current directory.
#png("./VolcanoPlot.png", res = 300, width = 4100, height = 2100)

# Renders the VolcanoPlot and writes it to the PNG file.
print(VolcanoPlot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off() # Turning off graphics device to free up memory. 
```

### Adding Log2 Fold Change cutoffs

Now we will create a volcano plot from res.strict.df that takes a lfcThreshold of 0.379(1.3 fold change), and padj of 0.01. Therefore, a gene is defined as differentially expressed (significant) only if \|lfcThreshold\| \> 0.379 and padj \<= 0.01.

```{r}
# Create a new dataframe(res.strict.df2) based on the original res.strict.df and add a new column(gene_category). The new gene_category column categorizes each row (gene) into one of these three groups: Upregulated, Downregulated, Non-Significant; based on the |log2FoldChange| > 0.379 and the padj(0.01) cutoffs. 
res.strict.df2 = res.strict.df %>%
  mutate(
    gene_category = case_when(
      log2FoldChange >= 0.379 & padj <= 0.01 ~ "Upregulated",
      log2FoldChange <= -0.379 & padj <= 0.01 ~ "Downregulated",
      TRUE ~ "Non-Significant")) 

# Extract the gene_category column from the new dataframe(res.strict.df2) and store it in a variable.
gene_category.object = res.df2$gene_category  

# Summarize the counts of each category in the gene_category column.
res.strict.df2 %>%
  count(gene_category) 
```

```{r}
# Check gene_category category names.
res.strict.df2 %>%
  distinct(gene_category) %>%
  pull()
```

```{r fig.width=10, fig.height=5, dpi=300, message=FALSE, warning=FALSE}
# Create vectors of custom colors and alphas (transparency) to volcano plot.
cols2 = c("Upregulated" = "#ffad73", "Downregulated" = "#26b3ff", "Non-Significant" = "grey") 
alphas2 = c("Upregulated" = 1, "Downregulated" = 1, "Non-Significant" = 0.5)

# Create a column in res.strict.df2 that takes the rownames of our 20 most significant differentially expressed genes that will be used later for labeling purposes. This is possible as res.strict.df2 is sorted in ascending order of the padj values.
res.strict.df2 = res.strict.df2 %>% mutate(top_20genes = ifelse(row_number() <= 20, rownames(res.df2), NA))

# Create Volcano plot in the same way we did in the previous steps.
VolcanoPlot_strict = ggplot( res.strict.df2, aes(x = log2FoldChange,
             y = -log10(padj),
             fill = gene_category,
             size = gene_category,
             alpha = gene_category)) + 
  geom_point(shape = 21,     
             colour = "black", size = 2) +  # Plot the points and modify color and size.
  geom_hline(yintercept = -log10(0.01),
             linetype = "dashed") + # Add dashed line in the y-axis at -log(0.01).
  geom_vline(xintercept = c(log2(1.3), -log2(1.3)), 
             linetype = "dashed") + # Add dashed line in the x-axis at log2(1.3) and -log2(1.3) fold change respectively.
  scale_fill_manual(values = cols2) + # Modify point color
  scale_alpha_manual(values = alphas2) + # Modify point transparency
  scale_x_continuous(breaks = c(seq(-6, 6, 1)), # Modify x-axis tick intervals.
                     limits = c(-6, 6)) + # Modify x-axis range from -6 to 6.
  ggtitle("ReEC(mutated) vs Control") + # Add title.
  theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5)) + # Format title.
  labs(subtitle = "(fold change = 1.3, adjusted p-value = 0.01)") + # Add subtitle.
  theme(plot.subtitle = element_text(size = 8, face = "italic", hjust = 0.5)) + # Formt subtitle.
  geom_text_repel(aes(label = top_20genes), # Add labels to the top 20 most significant differentially expressed genes.
                  size = 2, 
                  max.overlaps = Inf)

# Extracting VolcanoPlot_strict into a PNG file and saving it to our current directory.
#png("./VolcanoPlot_strict.png", res = 300, width = 4100, height = 2100)

# Renders the VolcanoPlot_strict and writes it to the PNG file.
print(VolcanoPlot_strict)

# "dev.off()" closes the graphics device, freeing up memory. 
#dev.off() 
```

### PCA plot with ggplot2 and ggrepel.

Making a function to detect our groups selection (mutated, control).

```{r}
detectGroups = function(x) { return(groups) }
```

```{r message=FALSE}
# Perform PCA to the regularized log transformed data. 
pca.object = prcomp(t(assay(rld)))  


  # Data preparation for plotting.

# Select the first two columns of pca.object which contains the principal component scores.
pcaData = as.data.frame(pca.object$x[,1:2]); 

# Add groups as a "Type" column in pcaData 
pcaData = cbind(pcaData, detectGroups(colnames(assay(rld)) ))

# Add column names
colnames(pcaData) = c("PC1", "PC2", "Type") 

# Calculate the percentage of variance explained by the first two principal components (PC1 and PC2). Use the summary(pca.object)$importance table to get the proportion of variance explained for each principal component and convert it to a percentage.
percentVar=round(100*summary(pca.object)$importance[2,1:2],0)


  # Plotting the PCA Results

# Initialize the ggplot object with the PCA data. Color and shape the points by the Type variable (which indicates the sample group).
p=ggplot(pcaData, aes(PC1, PC2, color=Type, shape = Type)) + geom_point(size=3)

# Label the x-axis and y-axis respectively with the percentages of variance explained by PC1 and PC2.
p=p+xlab(paste0("PC1: ",percentVar[1],"% variance")) 
p=p+ylab(paste0("PC2: ",percentVar[2],"% variance")) 

# Add title and ensure that the aspect ratio of the plot is equal, so the axes have the same scale.
p=p+ggtitle("Principal component analysis (PCA)") + coord_fixed(ratio=1.0) + 
    theme(plot.title = element_text(size = 12,hjust = 0.5)) + theme(aspect.ratio = 1) +
    theme(axis.text.x = element_text( size = 10),
    axis.text.y = element_text( size = 10),
    axis.title.x = element_text( size = 11),
    axis.title.y = element_text( size = 11) ) +
  theme(legend.text=element_text(size=11))

# Display plot
print(p)
```

### GO Term Enrichment Analysis with clusterProfiler

Making four extra columns in sigGenes of ENTREZ, GENENAME, ENSEMBL and GO IDs. We retrieve these IDs from org.Sc.sgd.db based on mapping to our row names (RefSeq ID type).

```{r}
# Make ENTREZ column and map RefSeq IDs to ENTREZ from org.Sc.sgd.db.
sigGenes$ENTREZ = mapIds(org.Sc.sgd.db, keys = rownames(sigGenes), column = "ENTREZID", keytype = "REFSEQ", multiVals = "first")

# Make GENENAME column and map RefSeq IDs to GENENAME from org.Sc.sgd.db.
sigGenes$GENENAME = mapIds(org.Sc.sgd.db, keys = rownames(sigGenes), column = "GENENAME", keytype = "REFSEQ", multiVals = "first")

# Make ENSEMBL column and map RefSeq IDs to ENSEMBL from org.Sc.sgd.db.
sigGenes$ENSEMBL = mapIds(org.Sc.sgd.db, keys = rownames(sigGenes), column = "ENSEMBL", keytype = "REFSEQ", multiVals = "first")

# Make GO column and map RefSeq IDs to GO from org.Sc.sgd.db.
sigGenes$GO = mapIds(org.Sc.sgd.db, keys = rownames(sigGenes), column = "GO", keytype = "REFSEQ", multiVals = "first")

```

Identifying upregulated and downregulated genes based on the log2FoldChange thresholds of (-0.379, 0.379), and extracting their corresponding ENTREZ IDs. Then, we store these genes to their respective objects.

```{r}
# Filter upregulated genes from sigGenes if log2FoldChange >= 0.379 and select the ENTREZ column from sigGenes. Store this to Upregulated_genes object. 
Upregulated_genes = sigGenes[sigGenes$log2FoldChange >= 0.379, "ENTREZ"]

# Remove NA values.
Upregulated_genes = na.omit(Upregulated_genes)

# Filter downregulated genes from sigGenes if log2FoldChange <= -0.379 and select the ENTREZ column from sigGenes. Store this to Downregulated_genes object.
Downregulated_genes = sigGenes[sigGenes$log2FoldChange <= (-0.379), "ENTREZ"]

# Remove NA values.
Downregulated_genes = na.omit(Downregulated_genes)
```

Performing Gene Ontology (GO) enrichment analysis for Biological Process (BP) terms using the enrichGO function from the clusterProfiler package. The enrichment analysis is conducted for Upregulated and Downregulated genes based on their ENTREZID identifiers. We have used the *Saccharomyces cerevisiae* (baker's yeast) database from the org.Sc.sgd.db to map our genes ENTREZ IDs to GO terms specific to yeast. Additionally, we have used a pvalueCutoff of 0.05 and also applied the Holm-Bonferroni correction to adjust p-values for multiple testing as stated in the paper.

```{r}
# Perform enrichGO for Upregulated genes.
Upregulated_genesBP = enrichGO(gene = Upregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "BP", pvalueCutoff = 0.05, pAdjustMethod = "holm")

# Perform enrichGO for Downregulated genes.
Downregulated_genesBP = enrichGO(gene = Downregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "BP", pvalueCutoff = 0.05, pAdjustMethod = "holm")
```

```{r}
# View Upregulated_genesBP as dataframe with scroll bars. 
kable(Upregulated_genesBP) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r}
# View Downregulated_genesBP as dataframe with scroll bars. 
kable(Downregulated_genesBP) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r fig.width=10, fig.height=15, message=FALSE, warning=FALSE}
# Plotting our results of Upregulated_genesBP in a barplot using ggplot2 and ggrepel for customization of the title.
Up_genesBP.plot = barplot(Upregulated_genesBP, showCategory = 30) + ggtitle("GO term Enrichment Analysis of Upregulated Genes (BP)") + 
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Up_genesBP.plot into a PNG file and saving it to our current directory.
#png("./Up_genesBP.png", res = 300, width = 3200, height = 5100)

# Renders the Up_genesBP.plot and writes it to the PNG file.
print(Up_genesBP.plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```

```{r fig.width=10, fig.height=7, message=FALSE, warning=FALSE}
# Plotting our results of Downregulated_genesBP in a barplot using ggplot2 and ggrepel for customization of the title.
Down_genesBP.plot = barplot(Downregulated_genesBP, showCategory = 20) + ggtitle("GO term Enrichment Analysis of Downregulated Genes (BP)") +
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Down_genesBP.plot into a PNG file and saving it to our current directory.
#png("./Down_genesBP.png", res = 300, width = 3200, height = 5100)

# Renders the Down_genesBP.plot and writes it to the PNG file.
print(Down_genesBP.plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```

Performing Gene Ontology (GO) enrichment analysis for Molecular Function (MF) terms using the enrichGO function from the clusterProfiler package. The enrichment analysis is conducted for Upregulated and Downregulated genes based on their ENTREZID identifiers. We have used the *Saccharomyces cerevisiae* (baker's yeast) database from the org.Sc.sgd.db to map our genes ENTREZ IDs to GO terms specific to yeast. Additionally, we have used a pvalueCutoff of 0.05 and also applied the Holm-Bonferroni correction to adjust p-values for multiple testing as stated in the paper.

```{r}
# Perform enrichGO for Upregulated genes.
Upregulated_genesMF = enrichGO(gene = Upregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "MF", pvalueCutoff = 0.05, pAdjustMethod = "holm")

# Perform enrichGO for Downregulated genes.
Downregulated_genesMF = enrichGO(gene = Downregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "MF", pvalueCutoff = 0.05, pAdjustMethod = "holm")
```

```{r}
# View Upregulated_genesMF as dataframe with scroll bars.
kable(Upregulated_genesMF) %>%
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r}
# View Downregulated_genesMF as dataframe with scroll bars.
kable(Downregulated_genesMF) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r fig.width=10, fig.height=14, message=FALSE, warning=FALSE}
# Plotting our results of Upregulated_genesMF in a barplot using ggplot2 and ggrepel for customization of the title.
Up_genesMF.plot = barplot(Upregulated_genesMF, showCategory = 30) + ggtitle("GO term Enrichment Analysis of Upregulated Genes (MF)") + 
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Up_genesMF.plot into a PNG file and saving it to our current directory.
#png("./Up_genesMF.png", res = 300, width = 3200, height = 5100)

# Renders the Up_genesMF.plot and writes it to the PNG file.
print(Up_genesMF.plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```

```{r fig.width=10, fig.height=9, message=FALSE, warning=FALSE}
# Plotting our results of Downregulated_genesMF in a barplot using ggplot2 and ggrepel for customization of the title.
Down_genesMF.plot = barplot(Downregulated_genesMF, showCategory = 20) + ggtitle("GO term Enrichment Analysis of Downregulated Genes (MF)") + 
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Down_genesMF.plot into a PNG file and saving it to our current directory.
#png("./Down_genesMF.png", res = 300, width = 3200, height = 5100)

# Renders the Down_genesMF.plot and writes it to the PNG file.
print(Down_genesMF.plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```

Performing Gene Ontology (GO) enrichment analysis for Cellular Component (CC) terms using the enrichGO function from the clusterProfiler package. The enrichment analysis is conducted for Upregulated and Downregulated genes based on their ENTREZID identifiers. We have used the *Saccharomyces cerevisiae* (baker's yeast) database from the org.Sc.sgd.db to map our genes ENTREZ IDs to GO terms specific to yeast. Additionally, we have used a pvalueCutoff of 0.05 and also applied the Holm-Bonferroni correction to adjust p-values for multiple testing as stated in the paper.

```{r echo=TRUE}
# Perform enrichGO for Upregulated genes.
Upregulated_genesCC = enrichGO(gene = Upregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "CC", pvalueCutoff = 0.05, pAdjustMethod = "holm")

# Perform enrichGO for Downregulated genes.
Downregulated_genesCC = enrichGO(gene = Downregulated_genes, OrgDb = "org.Sc.sgd.db", keyType = "ENTREZID", ont = "CC", pvalueCutoff = 0.05, pAdjustMethod = "holm")

# View Downregulated_genesCC as dataframe with scroll bars.
kable(Downregulated_genesCC) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r fig.width=10, fig.height=10, message=FALSE, warning=FALSE}
# Plotting our results of Downregulated_genesCC in a barplot using ggplot2 and ggrepel for customization of the title.
Down_genesCC.plot = barplot(Downregulated_genesCC, showCategory = 20) + ggtitle("GO term Enrichment Analysis of Downregulated Genes (CC)") + 
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Down_genesCC.plot into a PNG file and saving it to our current directory.
#png("./Down_genesCC.png", res = 300, width = 3200, height = 5100)

# Renders the Down_genesCC.plot and writes it to the PNG file.
print(Down_genesCC.plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```

```{r}
# View Upregulated_genesCC as dataframe.
as.data.frame(Upregulated_genesCC)
```

### Pathway Enrichment Analysis with clusterProfiler

Performing KEGG pathway enrichment analysis for upregulated and downregulated genes using the enrichKEGG function from the clusterProfiler package. The pathway enrichment analysis is conducted for Upregulated and Downregulated genes based on NCBI gene identifiers (ENTREZ IDs) that match to their respective IDs in KEGG pathway database. organism = "sce" specifies that the organism is *Saccharomyces cerevisiae*. KEGG uses a three-letter organism code; "sce" corresponds to yeast. Additionally, we have used a pvalueCutoff of 0.05 and also applied the Holm-Bonferroni correction to adjust p-values for multiple testing as stated in the paper.

```{r}
# Perform enrichKEGG for Upregulated_genes and store the results to Path_Upregulated_genes.
Path_Upregulated_genes = enrichKEGG(gene = Upregulated_genes, organism = "sce", keyType = "ncbi-geneid", pvalueCutoff = 0.05, pAdjustMethod = "holm", minGSSize = 5)

# Perform enrichKEGG for Downregulated_genes and store the results to Path_Downregulated_genes.
Path_Downregulated_genes = enrichKEGG(gene = Downregulated_genes, organism = "sce", keyType = "ncbi-geneid", pvalueCutoff = 0.05, pAdjustMethod = "holm", minGSSize = 5)
```

```{r}
# View Path_Upregulated_genes as dataframe with scroll bars.
kable(Path_Upregulated_genes) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "500px")
```

```{r}
# View Path_Downregulated_genes as dataframe with scroll bars.
kable(Path_Downregulated_genes) %>% 
  kable_styling() %>%
  scroll_box(width = "1000px", height = "800px")
```

```{r fig.width=10, fig.height=4, message=FALSE, warning=FALSE}
# Plotting our results of Path_Upregulated_genes in a barplot using ggplot2 and ggrepel for customization of the title.
Up_genesPath_plot = barplot(Path_Upregulated_genes, showCategory = 30) + ggtitle("Pathway Enrichment Analysis of Upregulated Genes") + 
  theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Up_genesPath_plot into a PNG file and saving it to our current directory.
#png("./Up_genesPath_plot.png", res = 300, width = 3000, height = 1000)

# Renders the Up_genesPath_plot and writes it to the PNG file.
print(Up_genesPath_plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()

```

```{r fig.width=10, fig.height=7, message=FALSE, warning=FALSE}
# Plotting our results of Path_Downregulated_genes in a barplot using ggplot2 and ggrepel for customization of the title.
Down_genesPath_plot = barplot(Path_Downregulated_genes, showCategory = 20) + ggtitle("Pathway Enrichment Analysis of Downregulated Genes") + theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

# Extracting Down_genesPath_plot into a PNG file and saving it to our current directory.
#png("./Down_genesPath_plot.png", res = 300, width = 3500, height = 2200)

# Renders the Down_genesPath_plot and writes it to the PNG file.
print(Down_genesPath_plot)

# "dev.off()" closes the graphics device, freeing up memory.
#dev.off()
```
